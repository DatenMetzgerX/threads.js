{"version":3,"sources":["../src/pool.js"],"names":[],"mappings":"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","file":"pool.js","sourcesContent":["import EventEmitter from 'eventemitter3';\nimport Job          from './job';\nimport defaults     from './defaults';\nimport { spawn }    from './';\n\nexport default class Pool extends EventEmitter {\n  constructor(threads) {\n    super();\n    this.threads = Pool.spawn(threads || defaults.pool.size);\n    this.idleThreads = this.threads.slice();\n    this.jobQueue = [];\n    this.runArgs = [];\n\n    this.on('newJob', this.handleNewJob.bind(this));\n\n  }\n\n  run(args) {\n    this.runArgs = args;\n    return this;\n  }\n\n  send(...args) {\n    if (!this.runArgs) {\n      throw new Error('Pool.send() called without prior Pool.run(). You need to define what to run first.');\n    }\n\n    let job = new Job(this);\n    job.run(this.runArgs);\n    return job.send(...args);\n  }\n\n  killAll() {\n    this.threads.forEach(thread => {\n      thread.kill();\n    });\n  }\n\n  queueJob(job) {\n    this.jobQueue.push(job);\n    this.dequeue();\n  }\n\n  dequeue() {\n    if (this.jobQueue.length === 0 || this.idleThreads.length === 0) {\n      return this.once('threadAvailable', this.dequeue);\n    }\n\n    const job = this.jobQueue.shift();\n    const thread = this.idleThreads.shift();\n\n    job\n      .once('done', this.handleJobSuccess.bind(this, thread, job))\n      .once('error', this.handleJobError.bind(this, thread, job));\n\n    job.executeOn(thread);\n  }\n\n  handleNewJob(job) {\n    this.lastCreatedJob = job;\n    job.once('readyToRun', this.queueJob.bind(this, job));    // triggered by job.send()\n  }\n\n  handleJobSuccess(thread, job, ...responseArgs) {\n    this.emit('done', job, ...responseArgs);\n    this.handleJobDone(thread);\n  }\n\n  handleJobError(thread, job, error) {\n    this.emit('error', job, error);\n    this.handleJobDone(thread);\n  }\n\n  handleJobDone(thread) {\n    this.idleThreads.push(thread);\n    this.emit('threadAvailable');\n\n    if (this.idleThreads.length === this.threads.length) {\n      // run deferred to give other job.on('done') handlers time to run first\n      setTimeout(() => { this.emit('finished'); }, 0);\n    }\n  }\n}\n\nPool.spawn = (threadCount) => {\n  const threads = [];\n\n  for (let threadIndex = 0; threadIndex < threadCount; threadIndex++) {\n    threads.push(spawn());\n  }\n\n  return threads;\n};\n"]}