{"version":3,"sources":["../../src/worker.node/slave.js"],"names":[],"mappings":";;AAAA;AACA;AACA,IAAM,KAAK,QAAQ,IAAR,CAAX;;AAEA,IAAI,sBAAsB,KAA1B;AACA,IAAI,iBAAiB,0BAAW;AAC9B,UAAQ,KAAR,CAAc,8BAAd,EAAkD;AACnD,CAFD;;AAIA,SAAS,iBAAT,GAA6B;AAC3B,MAAI,mBAAJ,EAAyB;AAAE;AAAS;;AAEpC,UAAQ,EAAR,CAAW,mBAAX,EAAgC,UAAS,KAAT,EAAgB;AAC9C,YAAQ,IAAR,CAAa;AACX,aAAQ,EAAE,SAAU,MAAM,OAAlB,EAA2B,OAAQ,MAAM,KAAzC;AADG,KAAb;AAGD,GAJD;;AAMA,wBAAsB,IAAtB;AACD;;AAGD,SAAS,oBAAT,CAA8B,IAA9B,EAAoC;AAClC,MAAI,UAAU;AACZ,kBADY;AAEZ,oBAFY;AAGZ,gCAHY;AAIZ,8BAJY;AAKZ,YAAgB,EAAE,SAAU,IAAZ,EALJ;AAMZ,oBANY;AAOZ,4BAPY;AAQZ;AARY,GAAd;;AAWA,KAAG,eAAH,CAAmB,IAAnB,EAAyB,OAAzB;AACA,SAAO,QAAQ,MAAR,CAAe,OAAtB;AACD;;AAGD,SAAS,kBAAT,GAAqC;AAAA,oCAAN,IAAM;AAAN,QAAM;AAAA;;AACnC,UAAQ,IAAR,CAAa,EAAE,UAAU,IAAZ,EAAb;AACD;;AAED,mBAAmB,QAAnB,GAA8B,YAAkB;AAAA,qCAAN,IAAM;AAAN,QAAM;AAAA;;AAC9C,OAAK,GAAL,GAAoB;AACpB,sCAAsB,IAAtB;AACD,CAHD;;AAKA,SAAS,sBAAT,CAAgC,QAAhC,EAA0C;AACxC,UAAQ,IAAR,CAAa,EAAE,kBAAF,EAAb;AACD;;AAGD,QAAQ,EAAR,CAAW,SAAX,EAAsB,UAAS,IAAT,EAAe;AACnC,MAAI,KAAK,YAAT,EAAuB;AACrB,qBAAiB,QAAQ,KAAK,MAAb,CAAjB;AACD;;AAED,MAAI,KAAK,YAAT,EAAuB;AACrB,qBAAiB,qBAAqB,sBAAsB,KAAK,MAAhD,CAAjB;AACD;;AAED,MAAI,KAAK,KAAT,EAAgB;AACd;AACA;AACA;;AAEA,mBAAe,KAAK,KAApB,EAA2B,kBAA3B,EAA+C,sBAA/C;AACD;AACF,CAhBD","file":"slave.js","sourcesContent":["// not using ES6 import/export syntax, since we need to require() in a handler\n// what the ES6 syntax does not permit\nconst vm = require('vm');\n\nlet errorCatcherInPlace = false;\nlet messageHandler = function() {\n  console.error('No thread logic initialized.');    // eslint-disable-line no-console\n};\n\nfunction setupErrorCatcher() {\n  if (errorCatcherInPlace) { return; }\n\n  process.on('uncaughtException', function(error) {\n    process.send({\n      error : { message : error.message, stack : error.stack }\n    });\n  });\n\n  errorCatcherInPlace = true;\n}\n\n\nfunction runAsSandboxedModule(code) {\n  var sandbox = {\n    Buffer,\n    console,\n    clearInterval,\n    clearTimeout,\n    module        : { exports : null },\n    require,\n    setInterval,\n    setTimeout\n  };\n\n  vm.runInNewContext(code, sandbox);\n  return sandbox.module.exports;\n}\n\n\nfunction messageHandlerDone(...args) {\n  process.send({ response: args });\n}\n\nmessageHandlerDone.transfer = function(...args) {\n  args.pop();         // ignore last parameter, since it's only useful for browser code\n  messageHandlerDone(...args);\n};\n\nfunction messageHandlerProgress(progress) {\n  process.send({ progress });\n}\n\n\nprocess.on('message', function(data) {\n  if (data.initByScript) {\n    messageHandler = require(data.script);\n  }\n\n  if (data.initByMethod) {\n    messageHandler = runAsSandboxedModule('module.exports = ' + data.method);\n  }\n\n  if (data.doRun) {\n    // it's a good idea to wait until first thread logic run to set this up,\n    // so initialization errors will be printed to console\n    setupErrorCatcher();\n\n    messageHandler(data.param, messageHandlerDone, messageHandlerProgress);\n  }\n});\n"]}